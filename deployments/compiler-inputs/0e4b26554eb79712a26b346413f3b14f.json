{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23+commit.f704f362",
	"id": "0e4b26554eb79712a26b346413f3b14f",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 200,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"lib/forge-std/src/Base.sol": {
					"*": []
				},
				"lib/forge-std/src/Script.sol": {
					"*": []
				},
				"lib/forge-std/src/StdChains.sol": {
					"*": []
				},
				"lib/forge-std/src/StdCheats.sol": {
					"*": []
				},
				"lib/forge-std/src/StdJson.sol": {
					"*": []
				},
				"lib/forge-std/src/StdMath.sol": {
					"*": []
				},
				"lib/forge-std/src/StdStorage.sol": {
					"*": []
				},
				"lib/forge-std/src/StdStyle.sol": {
					"*": []
				},
				"lib/forge-std/src/StdUtils.sol": {
					"*": []
				},
				"lib/forge-std/src/Vm.sol": {
					"*": []
				},
				"lib/forge-std/src/console.sol": {
					"*": []
				},
				"lib/forge-std/src/console2.sol": {
					"*": []
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"*": []
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"*": []
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"*": []
				},
				"lib/forge-std/src/safeconsole.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/script/helpers/CoreDeploymentLib.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBController.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBDirectory.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBERC20.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBFeelessAddresses.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBFundAccessLimits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBMultiTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBPermissions.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBPrices.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBProjects.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBRulesets.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBSplits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBTerminalStore.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/JBTokens.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/abstract/JBControlled.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/abstract/JBPermissioned.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/enums/JBApprovalStatus.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBControlled.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBController.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectory.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBDirectoryAccessControl.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFeelessAddresses.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBFundAccessLimits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBMigratable.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPayHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPriceFeed.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBPrices.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjectUriRegistry.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRedeemHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetApprovalHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesetDataHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBRulesets.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplitHook.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBSplits.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTerminalStore.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBToken.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/IJBTokens.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/terminal/IJBFeeTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/terminal/IJBMultiTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/terminal/IJBPayoutTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/terminal/IJBPermitTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/terminal/IJBRedeemTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/interfaces/terminal/IJBTerminal.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBConstants.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBFees.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBFixedPointNumber.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBMetadataResolver.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBRulesetMetadataResolver.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/libraries/JBSplitGroupIds.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBAccountingContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBAfterPayRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBAfterRedeemRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBBeforePayRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBBeforeRedeemRecordedContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBCurrencyAmount.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBFee.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBFundAccessLimitGroup.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBPayHookSpecification.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRedeemHookSpecification.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRuleset.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetConfig.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetMetadata.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWeightCache.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBRulesetWithMetadata.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSingleAllowanceContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSplit.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSplitGroup.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBSplitHookContext.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBTerminalConfig.sol": {
					"*": []
				},
				"node_modules/@bananapus/core/src/structs/JBTokenAmount.sol": {
					"*": []
				},
				"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
					"*": []
				},
				"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
					"*": []
				},
				"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
					"*": []
				},
				"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
					"*": []
				},
				"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/governance/utils/Votes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5805.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC6372.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721Votes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Address.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Context.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Create2.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Nonces.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/BitMaps.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/types/Time.sol": {
					"*": []
				},
				"node_modules/@prb/math/src/Common.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/SphinxDataTypes.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModule.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/core/interfaces/ISphinxModuleProxyFactory.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/StdUtils.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/Vm.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC165.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC20.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IERC721.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/interfaces/IMulticall3.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC20.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/forge-std/src/mocks/MockERC721.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/Sphinx.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxConstants.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxForkCheck.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPlugin.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxPluginTypes.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/SphinxUtils.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/ICreateCall.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IEnum.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafe.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxy.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IGnosisSafeProxyFactory.sol": {
					"*": []
				},
				"node_modules/@sphinx-labs/contracts/contracts/foundry/interfaces/IMultiSend.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
					"*": []
				},
				"script/Deploy.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/helpers/SuckerDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/BPOptimismSucker.sol": {
					"*": []
				},
				"src/BPSucker.sol": {
					"*": []
				},
				"src/BPSuckerHook.sol": {
					"*": []
				},
				"src/BPSuckerRegistry.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/deployers/BPOptimismSuckerDeployer.sol": {
					"*": []
				},
				"src/enums/BPAddToBalanceMode.sol": {
					"*": []
				},
				"src/interfaces/IBPSucker.sol": {
					"*": []
				},
				"src/interfaces/IBPSuckerDeployer.sol": {
					"*": []
				},
				"src/interfaces/IBPSuckerDeployerFeeless.sol": {
					"*": []
				},
				"src/interfaces/IBPSuckerRegistry.sol": {
					"*": []
				},
				"src/interfaces/OPMessenger.sol": {
					"*": []
				},
				"src/interfaces/OPStandardBridge.sol": {
					"*": []
				},
				"src/structs/BPClaim.sol": {
					"*": []
				},
				"src/structs/BPInboxTreeRoot.sol": {
					"*": []
				},
				"src/structs/BPLeaf.sol": {
					"*": []
				},
				"src/structs/BPMessageRoot.sol": {
					"*": []
				},
				"src/structs/BPOutboxTree.sol": {
					"*": []
				},
				"src/structs/BPRemoteToken.sol": {
					"*": []
				},
				"src/structs/BPSuckerDeployerConfig.sol": {
					"*": []
				},
				"src/structs/BPTokenMapping.sol": {
					"*": []
				},
				"src/utils/MerkleLib.sol": {
					"*": []
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=node_modules/@sphinx-labs/contracts/contracts/foundry/",
				"@arbitrum/=node_modules/@arbitrum/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@gnosis.pm/=node_modules/@gnosis.pm/",
				"@offchainlabs/=node_modules/@offchainlabs/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@uniswap/=node_modules/@uniswap/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solmate/=node_modules/solmate/",
				"sphinx-forge-std/=node_modules/sphinx-forge-std/",
				"sphinx-solmate/=node_modules/sphinx-solmate/",
				"sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"
			]
		},
		"sources": {
			"node_modules/@bananapus/core/src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint256[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n\n    function setTokenUriResolver(IJBTokenUriResolver newResolver) external;\n}\n"
			},
			"node_modules/@bananapus/core/src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"node_modules/@bananapus/core/src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint256 projectId;\n    uint256[] permissionIds;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\n\nimport {JBOwnableOverrides} from \"./JBOwnableOverrides.sol\";\n\ncontract JBOwnable is JBOwnableOverrides {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    constructor(IJBProjects projects, IJBPermissions permissions) JBOwnableOverrides(projects, permissions) {}\n\n    /// @notice Reverts if called by an address that is not the owner and does not have permission from the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n\n    function _emitTransferEvent(\n        address previousOwner,\n        address newOwner,\n        uint88 newProjectId\n    )\n        internal\n        virtual\n        override\n    {\n        emit OwnershipTransferred(previousOwner, newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId));\n    }\n}\n"
			},
			"node_modules/@bananapus/ownable/src/JBOwnableOverrides.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// Juicebox variation on OpenZeppelin Ownable\npragma solidity ^0.8.23;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IJBPermissions} from \"@bananapus/core/src/interfaces/IJBPermissions.sol\";\nimport {IJBPermissioned} from \"@bananapus/core/src/interfaces/IJBPermissioned.sol\";\nimport {IJBProjects} from \"@bananapus/core/src/interfaces/IJBProjects.sol\";\n\nimport {JBOwner} from \"./struct/JBOwner.sol\";\nimport {IJBOwnable} from \"./interfaces/IJBOwnable.sol\";\n\n/// @notice Access control module to grant exclusive access to a specified address (the owner) for specific functions.\n/// The owner can also grant access permissions to other addresses via `JBPermissions`.\n/// @dev Inherit this contract to make the `onlyOwner` modifier available. When applied to a function, this modifier\n/// restricts use to the owner and addresses with the appropriate permission from the owner.\n/// @dev Supports meta-transactions.\nabstract contract JBOwnableOverrides is Context, IJBOwnable, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors --------------------------//\n    //*********************************************************************//\n\n    error UNAUTHORIZED();\n    error INVALID_NEW_OWNER();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable PERMISSIONS;\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice This contract's owner information.\n    JBOwner public override jbOwner;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param projects The `IJBProjects` to use for tracking project ownership.\n    /// @param permissions The `IJBPermissions` to use for managing permissions.\n    constructor(IJBProjects projects, IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n        PROJECTS = projects;\n\n        _transferOwnership(_initialOwner());\n    }\n\n    //*********************************************************************//\n    // --------------------------- public methods ------------------------ //\n    //*********************************************************************//\n\n    /// @notice Returns the owner's address based on this contract's `JBOwner` owner information.\n    function owner() public view virtual returns (address) {\n        JBOwner memory ownerInfo = jbOwner;\n\n        if (ownerInfo.projectId == 0) {\n            return ownerInfo.owner;\n        }\n\n        return PROJECTS.ownerOf(ownerInfo.projectId);\n    }\n\n    /// @notice Gives up ownership of this contract, making it impossible to call `onlyOwner`/`_checkOwner` functions.\n    /// Can only be called by the current owner.\n    function renounceOwnership() public virtual {\n        _checkOwner();\n        _transferOwnership(address(0), 0);\n    }\n\n    /// @notice Transfers ownership of this contract to a new account (the `newOwner`). Can only be called by the\n    /// current owner.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function transferOwnership(address newOwner) public virtual {\n        _checkOwner();\n        if (newOwner == address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfer ownership of this contract to a new Juicebox project.\n    /// @dev The `projectId` must fit within a `uint88`.\n    /// @param projectId The ID of the project that should receive ownership of this contract.\n    function transferOwnershipToProject(uint256 projectId) public virtual {\n        _checkOwner();\n        if (projectId == 0 || projectId > type(uint88).max) {\n            revert INVALID_NEW_OWNER();\n        }\n\n        _transferOwnership(address(0), uint88(projectId));\n    }\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function setPermissionId(uint8 permissionId) public virtual {\n        _checkOwner();\n        _setPermissionId(permissionId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal methods ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets the permission ID which, when granted from the owner, allows other addresses to perform operations\n    /// on their behalf.\n    /// @dev Internal function without access restriction.\n    /// @param permissionId The ID of the permission to use for `onlyOwner`.\n    function _setPermissionId(uint8 permissionId) internal virtual {\n        jbOwner.permissionId = permissionId;\n        emit PermissionIdChanged(permissionId);\n    }\n\n    /// @notice Helper to allow for drop-in replacement of OpenZeppelin.\n    /// @param newOwner The address that should receive ownership of this contract.\n    function _transferOwnership(address newOwner) internal virtual {\n        _transferOwnership(newOwner, 0);\n    }\n\n    /// @notice Transfers this contract's ownership to an address (`newOwner`) OR a Juicebox project (`projectId`).\n    /// @dev Updates this contract's `JBOwner` owner information.\n    /// @dev If both `newOwner` and `projectId` are set, this will revert.\n    /// @dev Internal function without access restriction.\n    /// @param newOwner The address that should receive ownership of this contract.\n    /// @param projectId The ID of the project that this contract should respect the ownership of.\n    function _transferOwnership(address newOwner, uint88 projectId) internal virtual {\n        // Can't set both a new owner and a new project ID.\n        if (projectId != 0 && newOwner != address(0)) {\n            revert INVALID_NEW_OWNER();\n        }\n        // Load the owner information from storage.\n        JBOwner memory ownerInfo = jbOwner;\n        // Get the address of the old owner.\n        address oldOwner = ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId);\n        // Update the stored owner information to the new owner and reset the `permissionId`.\n        // This is to prevent permissions clashes for the new user/owner.\n        jbOwner = JBOwner({owner: newOwner, projectId: projectId, permissionId: 0});\n        // Emit a transfer event with the new owner's address.\n        _emitTransferEvent(oldOwner, newOwner, projectId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Reverts if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        JBOwner memory ownerInfo = jbOwner;\n\n        _requirePermissionFrom({\n            account: ownerInfo.projectId == 0 ? ownerInfo.owner : PROJECTS.ownerOf(ownerInfo.projectId),\n            projectId: ownerInfo.projectId,\n            permissionId: ownerInfo.permissionId\n        });\n    }\n\n    /// @notice Only allows the specified account or an operator with the specified permission ID from that account to\n    /// proceed.\n    /// @param account The account to allow.\n    /// @param projectId The ID of the project to look for an operator within.\n    /// @param permissionId The ID of the permission to check for.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view virtual {\n        address sender = _msgSender();\n        if (\n            sender != account && !PERMISSIONS.hasPermission(sender, account, projectId, permissionId)\n                && !PERMISSIONS.hasPermission(sender, account, 0, permissionId)\n        ) revert UNAUTHORIZED();\n    }\n\n    /// @notice If the `override` flag is true, proceed. Otherwise, only allows the specified account or an operator\n    /// with the specified permission ID from that account to proceed.\n    /// @param account The account to allow.\n    /// @param projectId The ID of the pproject to look for an operator within. TODO: remove\n    /// @param permissionId The ID of the permission to check for.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.     */\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n        virtual\n    {\n        // Return early if the override flag is true.\n        if (alsoGrantAccessIf) return;\n        // Otherwise, perform a standard check.\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n\n    /// @notice returns the address that should become the owner on deployment.\n    /// @return _owner the address that will become the owner when this contract is deployed.\n    function _initialOwner() internal view virtual returns (address _owner) {\n        return _msgSender();\n    }\n\n    /// @notice Either `newOwner` or `newProjectId` is non-zero or both are zero. But they can never both be non-zero.\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId) internal virtual;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/interfaces/IJBOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IJBOwnable {\n    event PermissionIdChanged(uint8 newIndex);\n\n    function jbOwner() external view returns (address owner, uint88 projectOwner, uint8 permissionId);\n\n    function transferOwnershipToProject(uint256 projectId) external;\n\n    function setPermissionId(uint8 permissionId) external;\n}\n"
			},
			"node_modules/@bananapus/ownable/src/struct/JBOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/// @notice Owner information for a given instance of `JBOwnableOverrides`.\n/// @custom:member owner If `projectId` is 0 and this is set, this static address has owner access.\n/// @custom:member projectId Unless this is 0, this project's owner has owner access.\n/// @custom:member permissionId The ID of the permission required from the project's owner to have owner access. See\n/// `JBPermissions` in `juice-contracts-v4`.\nstruct JBOwner {\n    address owner;\n    uint88 projectId;\n    uint8 permissionId;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem.\nlibrary JBPermissionIds {\n    // nana-core\n    uint256 internal constant ROOT = 1;\n    uint256 internal constant QUEUE_RULESETS = 2;\n    uint256 internal constant REDEEM_TOKENS = 3;\n    uint256 internal constant MIGRATE_CONTROLLER = 4;\n    uint256 internal constant MIGRATE_TERMINAL = 5;\n    uint256 internal constant PROCESS_FEES = 6;\n    uint256 internal constant SET_PROJECT_METADATA = 7;\n    uint256 internal constant ISSUE_TOKEN = 8;\n    uint256 internal constant SET_TOKEN = 9;\n    uint256 internal constant MINT_TOKENS = 10;\n    uint256 internal constant BURN_TOKENS = 11;\n    uint256 internal constant CLAIM_TOKENS = 12;\n    uint256 internal constant TRANSFER_TOKENS = 13;\n    uint256 internal constant SET_CONTROLLER = 14;\n    uint256 internal constant SET_TERMINALS = 15;\n    uint256 internal constant SET_PRIMARY_TERMINAL = 16;\n    uint256 internal constant USE_ALLOWANCE = 17;\n    uint256 internal constant SET_SPLITS = 18;\n    uint256 internal constant ADD_PRICE_FEED = 19;\n    uint256 internal constant SET_ACCOUNTING_CONTEXT = 20;\n    // nana-project-handles\n    uint256 internal constant SET_ENS_NAME_FOR = 21;\n    // nana-721-hook\n    uint256 internal constant ADJUST_721_TIERS = 22;\n    uint256 internal constant UPDATE_721_METADATA = 23;\n    uint256 internal constant MINT_721 = 24;\n    // nana-buyback-hook\n    uint256 internal constant SET_BUYBACK_POOL_PARAMS = 25;\n    uint256 internal constant CHANGE_BUYBACK_POOL = 26;\n    // nana-swap-terminal\n    uint256 internal constant MODIFY_DEFAULT_SWAP_TERMINAL_POOL = 27;\n    uint256 internal constant MODIFY_SWAP_TERMINAL_TWAP_PARAMS = 28;\n    // nana-suckers\n    uint256 internal constant MAP_SUCKER_TOKEN = 29;\n    uint256 internal constant DEPLOY_SUCKERS = 30;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
			},
			"src/BPSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {JBOwnable, IJBProjects, IJBPermissions} from \"@bananapus/ownable/src/JBOwnable.sol\";\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {EnumerableMap} from \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport {IBPSucker} from \"./interfaces/IBPSucker.sol\";\nimport {IBPSuckerRegistry} from \"./interfaces/IBPSuckerRegistry.sol\";\nimport {BPSuckerDeployerConfig} from \"./structs/BPSuckerDeployerConfig.sol\";\n\ncontract BPSuckerRegistry is JBOwnable, IBPSuckerRegistry {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n    error INVALID_DEPLOYER(address deployer);\n\n    event SuckerDeployerAllowed(address deployer);\n\n    /// @notice A constant indicating that this sucker exists and belongs to a specific project.\n    uint256 constant SUCKER_EXISTS = 1;\n\n    /// @notice Tracks the suckers for the specified project.\n    mapping(uint256 => EnumerableMap.AddressToUintMap) _suckersOf;\n\n    /// @notice Tracks whether the specified sucker deployer is approved by this registry.\n    mapping(address deployer => bool) public suckerDeployerIsAllowed;\n\n    constructor(IJBProjects projects, IJBPermissions permissions, address _initialOwner)\n        JBOwnable(projects, permissions)\n    {\n        // Transfer ownership to the deployer, will soon after be transfered back to JBDAO.\n        _transferOwnership(address(_initialOwner), uint88(0));\n    }\n\n    /// @notice Returns true if the specified sucker belongs to the specified project, and was deployed through this registry.\n    /// @param projectId The ID of the project to check for.\n    /// @param suckerAddress The address of the sucker to check.\n    function isSuckerOf(uint256 projectId, address suckerAddress) external view returns (bool) {\n        return _suckersOf[projectId].get(suckerAddress) == SUCKER_EXISTS;\n    }\n\n    /// @notice Gets all of the specified project's suckers which were deployed through this registry.\n    /// @param projectId The ID of the project to get the suckers of.\n    function suckersOf(uint256 projectId) external view returns (address[] memory) {\n        return _suckersOf[projectId].keys();\n    }\n\n    /// @notice Adds a suckers deployer to the allowlist.\n    /// @dev Can only be called by this contract's owner (initially project ID 1, or JuiceboxDAO).\n    /// @param deployer The address of the deployer to add.\n    function allowSuckerDeployer(address deployer) public override onlyOwner {\n        suckerDeployerIsAllowed[deployer] = true;\n        emit SuckerDeployerAllowed(deployer);\n    }\n\n    /// @notice Adds multiple suckers deployer to the allowlist.\n    /// @dev Can only be called by this contract's owner (initially project ID 1, or JuiceboxDAO).\n    /// @param deployers The address of the deployer to add.\n    function allowSuckerDeployers(address[] calldata deployers) public onlyOwner {\n        for (uint256 _i; _i < deployers.length; _i++) {\n            suckerDeployerIsAllowed[deployers[_i]] = true;\n            emit SuckerDeployerAllowed(deployers[_i]);\n        }\n    }\n\n    /// @notice Deploy one or more suckers for the specified project.\n    /// @dev The caller must be the project's owner or have `JBPermissionIds.DEPLOY_SUCKERS` from the project's owner.\n    /// @param projectId The ID of the project to deploy suckers for.\n    /// @param salt The salt used to deploy the contract. For the suckers to be peers, this must be the same value on each chain where suckers are deployed.\n    /// @param configurations The sucker deployer configs to use to deploy the suckers.\n    /// @return suckers The addresses of the deployed suckers.\n    function deploySuckersFor(uint256 projectId, bytes32 salt, BPSuckerDeployerConfig[] calldata configurations)\n        public\n        override\n        returns (address[] memory suckers)\n    {\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.DEPLOY_SUCKERS\n        });\n\n        // Create an array to store the suckers as they are deployed.\n        suckers = new address[](configurations.length);\n\n        // Calculate the salt using the sender's address and the provided `salt`.\n        // This means that for suckers to be peers, the sender has to be the same on each chain.\n        salt = keccak256(abi.encode(msg.sender, salt));\n\n        // Iterate through the configurations and deploy the suckers.\n        for (uint256 i; i < configurations.length; i++) {\n            // Make sure the deployer is allowed.\n            if (!suckerDeployerIsAllowed[address(configurations[i].deployer)]) {\n                revert INVALID_DEPLOYER(address(configurations[i].deployer));\n            }\n\n            // Create the sucker.\n            IBPSucker sucker = configurations[i].deployer.createForSender({localProjectId: projectId, salt: salt});\n            suckers[i] = address(sucker);\n\n            // Store the sucker as being deployed for this project.\n            _suckersOf[projectId].set(address(sucker), SUCKER_EXISTS);\n\n            // Map the tokens for the sucker.\n            sucker.mapTokens(configurations[i].mappings);\n        }\n    }\n\n    // /// @notice returns the address that should become the owner on deployment.\n    // /// @return _owner the address that will become the owner when this contract is deployed.\n    // // TODO: have this return both _owner and _projectId, so we can set the initial project ID.\n    // function _initialOwner() internal view virtual override returns (address _owner) {\n    //     return address(0);\n    // }\n\n    function _emitTransferEvent(address previousOwner, address newOwner, uint88 newProjectId)\n        internal\n        virtual\n        override\n    {\n        // Only emit after the initial transfer.\n        // TODO: improve this.\n        if (previousOwner != address(0) && newProjectId != 1) {\n            emit OwnershipTransferred(previousOwner, newProjectId == 0 ? newOwner : PROJECTS.ownerOf(newProjectId));\n        }\n    }\n}\n"
			},
			"src/interfaces/IBPSucker.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BPTokenMapping} from \"../structs/BPTokenMapping.sol\";\n\ninterface IBPSucker {\n    function isMapped(address token) external view returns (bool);\n\n    function prepare(uint256 projectTokenAmount, address beneficiary, uint256 minTokensReclaimed, address token)\n        external;\n\n    function mapToken(BPTokenMapping calldata map) external;\n\n    function mapTokens(BPTokenMapping[] calldata maps) external;\n\n    event NewInboxTreeRoot(address indexed token, uint64 nonce, bytes32 root);\n\n    event RootToRemote(bytes32 indexed root, address indexed terminalToken, uint256 index, uint64 nonce);\n\n    event InsertToOutboxTree(\n        address indexed beneficiary,\n        address indexed terminalToken,\n        bytes32 hashed,\n        uint256 index,\n        bytes32 root,\n        uint256 projectTokenAmount,\n        uint256 terminalTokenAmount\n    );\n}\n"
			},
			"src/interfaces/IBPSuckerDeployer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBPSucker} from \"./IBPSucker.sol\";\n\ninterface IBPSuckerDeployer {\n    function createForSender(uint256 localProjectId, bytes32 salt) external returns (IBPSucker sucker);\n}\n"
			},
			"src/interfaces/IBPSuckerRegistry.sol": {
				"content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.21;\n\nimport {BPSuckerDeployerConfig} from \"../structs/BPSuckerDeployerConfig.sol\";\n\ninterface IBPSuckerRegistry {\n    function isSuckerOf(uint256 projectId, address suckerAddress) external view returns (bool);\n    function suckersOf(uint256 projectId) external view returns (address[] memory);\n    function suckerDeployerIsAllowed(address deployer) external view returns (bool);\n\n    function allowSuckerDeployer(address deployer) external;\n    function deploySuckersFor(uint256 projectId, bytes32 salt, BPSuckerDeployerConfig[] memory configurations)\n        external\n        returns (address[] memory suckers);\n}\n"
			},
			"src/structs/BPSuckerDeployerConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBPSuckerDeployer} from \"../interfaces/IBPSuckerDeployer.sol\";\nimport {BPTokenMapping} from \"./BPTokenMapping.sol\";\n\nstruct BPSuckerDeployerConfig {\n    IBPSuckerDeployer deployer;\n    BPTokenMapping[] mappings;\n}\n"
			},
			"src/structs/BPTokenMapping.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct BPTokenMapping {\n    address localToken;\n    uint32 minGas;\n    address remoteToken;\n    uint256 minBridgeAmount;\n}\n"
			}
		}
	}
}